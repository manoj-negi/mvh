// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: cost.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCost = `-- name: CreateCost :one
INSERT INTO cost (
    cost_input_id,
    cost_type_id,
    period_id,
    title,
    is_deleted
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, cost_input_id, cost_type_id, period_id, title, is_deleted, created_at, updated_at
`

type CreateCostParams struct {
	CostInputID pgtype.Int4 `json:"cost_input_id"`
	CostTypeID  pgtype.Int4 `json:"cost_type_id"`
	PeriodID    pgtype.Int4 `json:"period_id"`
	Title       string      `json:"title"`
	IsDeleted   pgtype.Bool `json:"is_deleted"`
}

func (q *Queries) CreateCost(ctx context.Context, arg CreateCostParams) (Cost, error) {
	row := q.db.QueryRow(ctx, createCost,
		arg.CostInputID,
		arg.CostTypeID,
		arg.PeriodID,
		arg.Title,
		arg.IsDeleted,
	)
	var i Cost
	err := row.Scan(
		&i.ID,
		&i.CostInputID,
		&i.CostTypeID,
		&i.PeriodID,
		&i.Title,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllCost = `-- name: GetAllCost :many
SELECT id, cost_input_id, cost_type_id, period_id, title, is_deleted, created_at, updated_at FROM cost
`

func (q *Queries) GetAllCost(ctx context.Context) ([]Cost, error) {
	rows, err := q.db.Query(ctx, getAllCost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cost{}
	for rows.Next() {
		var i Cost
		if err := rows.Scan(
			&i.ID,
			&i.CostInputID,
			&i.CostTypeID,
			&i.PeriodID,
			&i.Title,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
